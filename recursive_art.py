""" Creates Lovely Art Generated By Random Equations"""

import random
from PIL import Image
import math


def build_random_function(min, max, depth=0):
	""" Builds a random function of depth at least min_depth and depth
		at most max_depth (see assignment writeup for definition of depth
		in this context)

		min_depth: the minimum depth of the random function
		max_depth: the maximum depth of the random function
		returns: the randomly generated function represented as a nested list
		(see assignment writeup for details on the representation of
		these functions)
	"""

	operators = ["prod", "avg", "x(a,b)", "y(a,b)", "hypot", "cos_pi", "sin_pi", "tan_pi"]

	if min <= 1:
		min = 1
	depth = random.randint(min, max)
	if depth > 1:
		func_depth = random.randint(0, 7)
		if func_depth <= 4:
			return [operators[func_depth], build_random_function(min-1, max-1), build_random_function(min-1, max-1)]
		else:
			return [operators[func_depth], build_random_function(min-1, max-1)]

	else: 
		func_depth = random.randint(0,1)
		if func_depth == 0:
			return["x"]
		else:
			return["y"]


def evaluate_random_function(f, x, y):
	""" Evaluate the random function f with inputs a,b
		Representation of the function f is defined in the assignment writeup

		f: the function to evaluate
		x: the value of x to be used to evaluate the function
		y: the value of y to be used to evaluate the function
		returns: the function value

		>>> evaluate_random_function(["x"],-0.5, 0.75)
		-0.5
		>>> evaluate_random_function(["y"],0.1,0.02)
		0.02
		>>> evaluate_random_function(["prod", ["x"], ["y"]], 0.5, 0.5)
		0.25
		>>> evaluate_random_function(["avg", ["x"], ["y"]], 0.5, 0.3)
		0.4
		>>> evaluate_random_function(["sin_pi", ["x"]], 0.5, 0.0)
		1.0
		>>> evaluate_random_function(["cos_pi", ["x"]], 1.0, 0.0)
		-1.0
		>>> evaluate_random_function(["tan_pi", ["x"]], 0.0, 0.0)
		0.0
		>>> evaluate_random_function(["x(a,b)", ["x"], ["y"]], 1.0, 0.5)
		1.0
		>>> evaluate_random_function(["y(a,b)", ["x"], ["y"]], 1.0, 0.5)
		0.5
		>>> evaluate_random_function(["hypot", ["x"], ["y"]], math.sqrt(2)/2, math.sqrt(2)/2)
		1.0

	"""
	if f[0] == "x":
		return x
	elif f[0] == "y":
		return y
	elif f[0] == "prod":
		return evaluate_random_function(f[1], x, y) * evaluate_random_function(f[2], x, y)
	elif f[0] == "avg":
		return (evaluate_random_function(f[1], x, y) + evaluate_random_function(f[2], x, y))*.5
	elif f[0] == "hypot":
		return math.hypot(evaluate_random_function(f[1], x, y), evaluate_random_function(f[2], x, y))
	elif f[0] == "sin_pi":
		return math.sin(math.pi * evaluate_random_function(f[1], x, y))
	elif f[0] == "cos_pi":
		return math.cos(math.pi * evaluate_random_function(f[1], x, y))
	elif f[0] == "tan_pi":
		return math.tan(math.pi * evaluate_random_function(f[1], x, y))
	elif f[0] == "x(a,b)":
		return x
	elif f[0] == "y(a,b)":
		return y
	# I know the last two are the same as the first, but adding them smooths out the images and makes them look nicer

def remap_interval(val, 
	input_start, 
	input_end, 
	output_start, 
	output_end):
    """ Given an input value in the interval [input_start,
        input_end], return an output value scaled to fall within
        the output interval [output_start, output_end].

        val: the value to remap
        input_start: the start of the interval that contains all
                              possible values for val
        input_end: the end of the interval that contains all possible
                            values for val
        output_start: the start of the interval that contains all
                               possible output values
        output_end: the end of the interval that contains all possible
                            output values
        returns: the value remapped from the input to the output interval

        >>> remap_interval(0.5, 0, 1, 0, 10)
        5.0
        >>> remap_interval(5, 4, 6, 0, 2)
        1.0
        >>> remap_interval(5, 4, 6, 1, 2)
        1.5
    """

    new_val = (((float(val)) - float(input_start)) * (float(output_end) - float(output_start)) / 
    		  (float(input_end) - float(input_start))) + float(output_start)
    return new_val

def color_map(val):
    """ Maps input value between -1 and 1 to an integer 0-255, suitable for
        use as an RGB color code.

        val: value to remap, must be a float in the interval [-1, 1]
        returns: integer in the interval [0,255]

        >>> color_map(-1.0)
        0
        >>> color_map(1.0)
        255
        >>> color_map(0.0)
        127
        >>> color_map(0.5)
        191
    """
    # NOTE: This relies on remap_interval, which you must provide
    color_code = remap_interval(val, -1, 1, 0, 255)
    return int(color_code)


def test_image(filename, x_size=350, y_size=350):
    """ Generate test image with random pixels and save as an image file.

        filename: string filename for image (should be .png)
        x_size, y_size: optional args to set image dimensions (default: 350)
    """
    # Create image and loop over all pixels
    im = Image.new("RGB", (x_size, y_size))
    pixels = im.load()
    for i in range(x_size):
        for j in range(y_size):
            x = remap_interval(i, 0, x_size, -1, 1)
            y = remap_interval(j, 0, y_size, -1, 1)
            pixels[i, j] = (random.randint(0, 255),  # Red channel
                            random.randint(0, 255),  # Green channel
                            random.randint(0, 255))  # Blue channel

def generate_art(filename, x_size=350, y_size=350):
	""" Generate computational art and save as an image file.

		filename: string filename for image (should be .png)
		x_size, y_size: optional args to set image dimensions (default: 350)
	"""
	# Functions for red, green, and blue channels - where the magic happens!
	red_function = build_random_function(5, 7)
	green_function = build_random_function(5, 7)
	blue_function = build_random_function(5, 7)

	# Create image and loop over all pixels
	im = Image.new("RGB", (x_size, y_size))
	pixels = im.load()
	for i in range(x_size):
		for j in range(y_size):
			x = remap_interval(i, 0, x_size, -1, 1)
			y = remap_interval(j, 0, y_size, -1, 1)
			pixels[i, j] = (
			color_map(evaluate_random_function(red_function, x, y)),
			color_map(evaluate_random_function(green_function, x, y)),
			color_map(evaluate_random_function(blue_function, x, y))
			)

	im.save(filename)


if __name__ == '__main__':
    import doctest
    doctest.testmod()
for i in range(5):
	filename = "image" + str(i+1) + ".png"
	generate_art(filename)

    # Test that PIL is installed correctly
    # TODO: Comment or remove this function call after testing PIL install
    # test_image("noise.png")
